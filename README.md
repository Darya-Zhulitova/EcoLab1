# Лабораторная работа: Алгоритм сортировки Comb Sort

## 1. Задача
Требуется разработать программный COM компонент, который реализует сортировку целочисленных массивов с применением алгоритма Comb Sort (сортировка расчёской).

## 2. Реализуемый алгоритм сортировки (Comb Sort)

Алгоритм Comb Sort представляет собой модифицированный вариант пузырьковой сортировки, в котором устранена проблема медленного перемещения элементов с малыми значениями, расположенных в конце массива. Ключевая особенность метода заключается в использовании динамически изменяющегося интервала сравнения элементов, который последовательно сокращается в процессе работы.

**Основные этапы выполнения алгоритма сортировки расчёской**

* Устанавливается начальное значение интервала сравнения, равное размеру сортируемого массива;
* На каждой итерации производится попарное сравнение элементов, разделенных текущим интервалом;
* При обнаружении пары элементов, нарушающих требуемый порядок следования, выполняется их взаимная перестановка;
* После завершения каждого прохода по массиву интервал уменьшается с применением коэффициента сокращения;
* Процесс повторяется до тех пор, пока интервал не достигнет единицы и не будет выполнена полная итерация без перестановок;
* В качестве оптимизации часто используется коэффициент сокращения 1.3, что подтверждено эмпирическими исследованиями.

## 3. Асимптотика

**Временная сложность:**

* Наихудший сценарий: O(n²) - встречается в отдельных случаях
* Средний случай: O(n²) - для базовой реализации
* Оптимальный случай: O(n) - при удачном подборе коэффициента сокращения

**Сложность по памяти:** O(1) - алгоритм осуществляет сортировку in-place без использования дополнительной памяти, пропорциональной размеру входных данных.

## 4. Реализация
```c
// Основной цикл сортировки расческой
while (gap > 1 || swapped) {
    // Вычисляем следующий зазор (обычно используется коэффициент 1.3)
    gap = (size_t)((double)gap / 1.3);
    if (gap < 1) {
        gap = 1;
    }

    swapped = 0;

    // Проходим по массиву с текущим зазором
    for (i = 0; i + gap < num; i++) {
        char* elem1 = (char*)base + i * size;
        char* elem2 = (char*)base + (i + gap) * size;

        // Сравниваем и при необходимости меняем элементы
        if (compare(elem1, elem2) > 0) {
            swap(elem1, elem2, size);
            swapped = 1;
        }
    }
}
```

## 5. Сравнение с qsort из стандартной библиотеки

Экспериментальное исследование проводилось на массивах размеров, соответствующих степеням числа 2, что позволяет наиболее наглядно проанализировать асимптотическое поведение алгоритмов и выявить закономерности их работы.

Измерение временных характеристик выполнялось с помощью функции clock() из стандартной библиотеки time.h, что гарантирует корректное определение времени, затрачиваемого на выполнение алгоритмов.

**Результаты производительности:**
<img width="1280" height="684" alt="image" src="https://github.com/user-attachments/assets/8bc12205-f42a-4722-8fc9-8af906c5db6c" />

**Анализ результатов:**
1. Область малых размеров (n ≤ 512):
* Оба алгоритма показывают близкое к нулю время выполнения
* Время измерения меньше точности таймера, поэтому сравнение на малых значениях не будет достоверным.

2. Область средних размеров (n = 1024-8192):
* Появляются первые значимые измерения
* qsort показывает нестабильные результаты. Для большинства значений время всё еще меньше точности таймера (0ms в некоторых точках).
* Comb Sort начинает проявлять предсказуемый рост.

3. Область больших размеров (n ≥ 32768):
* Четко видно преимущество qsort
* Оба алгоритма демонстрируют ожидаемый рост времени выполнения.

## 6. Выводы
На основании проведенного анализа можно сделать однозначный вывод о существенном преимуществе алгоритма Qsort над Comb Sort. Хотя оба алгоритма демонстрируют схожую производительность на малых объемах данных, с ростом размера массива разница становится критической. Qsort сохраняет близкую к O(n log n) асимптотику, в то время как Comb Sort проявляет квадратичную сложность, что приводит к многократному отставанию - от 5-кратного на средних размерах до 11-кратного на больших массивах. Полученные результаты подтверждают теоретические ожидания и свидетельствуют о нецелесообразности практического применения Comb Sort в сравнении с эффективными алгоритмами типа qsort для работы с крупными наборами данных.

---
